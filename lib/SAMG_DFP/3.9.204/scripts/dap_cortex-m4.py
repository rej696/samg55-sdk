# This file is autogenerated
comm_speed=2000000
erase_as_needed = True
reset_delay = 0
has_reset = True
show_output = False
log_level = 0
has_connected = False
comm_iface = True # default to swd

def _begin_debug_session():
    ensure_connect()
    reset_and_halt()
    cache_onDebugStart()

def _begin_communication_session(): 
    global log_level,show_output,reset_delay, target_was_reset, has_reset, _stealth_runstate    , has_connected
    log_level    = settings.getNumeric("script.log_level",log_level)
    show_output  = settings.getBool("script.show_output",show_output)
    has_reset  = settings.getBool("script.has_reset",has_reset)
    reset_delay = settings.getNumeric("script.reset_delay",reset_delay)
    has_connected = False
    target_was_reset = False
    _stealth_runstate = 2
    dev.SetApiLogging(log_level)
    log.setShowOutput(show_output)

    global comm_iface, comm_speed, erase_as_needed
    comm_iface = settings.getString("communication.interface", "swd") == "swd"
    comm_speed = settings.getNumeric("communication.frequency", comm_speed)
    erase_as_needed = True  

    init_mem_handlers()

def _end_communication_session(): 
    global has_connected
    dev.Disconnect()
    has_connected = False


def onShowPropsDFP2(t):
    ide.addBooleanProperty(t,"arm.use_vtor" , "*|programoptions|programoptions.eraseb4program","Set PC and SP to VTOR","After reset, force PC and SP to the entries defined by the VTOR", False)
    ide.addTextProperty(t,"arm.vtor_adr" , "*|programoptions|programoptions.eraseb4program","VTOR table or numerical address", "Enter address of vector table", "exception_table")
    ide.addPropCategory(t,"diagnostics" , "*|toolpack", "Diagnostics")
    ide.addBooleanProperty(t,"script.show_output" , "*|diagnostics|*","Output diagnostic logging","Show diagnostic text in the Output window", False)
    ide.addTextProperty(t,"script.log_level" , "*|diagnostics|*","Diagnostic log level","Set diagnostic level (usually 0 1 or 3)", "1")
    ide.addTextProperty(t,"script.reset_delay" , "*|diagnostics|*","Additional delay after reset","Enter additional RST settling delay in msec", "0")
    ide.addBooleanProperty(t,"script.has_reset" , "*|diagnostics|*","Uncheck if RESET line is not wired","Normally checked. Uncheck if the target does not have RST connected to the debugger", True)
    ide.addTextProperty(t, "loader.board_file", "*|programoptions|**","Board file path","Set the path of board file", "${ProjectDir}/board.xboard")

def print_dhcsr_v(t, d):
    log.info(t + arm.getDHCSRString(d))

def print_dhcsr(text):
    try:
        d = dev.Read32(arm.DHCSR)
        print_dhcsr_v(text, d)
        return d
    except:
        log.log("DHCSR is unreadable")
        return 0

def _debug_read(mt, start, length, data):
    cache_onDataRead(start, length)
    try:
        dev.Read(start, data, 0, length)
    except:
        for i in range(len(data)):
            try:
                dev.Read(start + i, data, i, 1)
            except:
                data[i] = b'?'
                dev.Delay(reset_delay)
        log.info("Debug: an error occurred while reading address 0x%x length 0x%0x" % (start, length))

def _debug_write(mt, start, length, data):
    if str(mt) == "Pgm":
        cache_invalidateInstrCache()
        try:
            _flash_write(start, length, data, True)
        except:
            for i in range(len(data)):
                try:
                    _flash_write(start + i * 4, 1, data[i], True)
                except:
                    dev.Delay(reset_delay)
            log.info("Debug: an error occurred while writing address 0x%x length 0x%0x" % (start, length))
        return

    cache_onDataWrite(start, length)
    try:
        dev.Write(start, data, 0, length)
    except:
        for i in range(len(data)):
            try:
                dev.Write(start + i, data, i, 1)
            except:
                dev.Delay(reset_delay)
        log.info("Debug: an error occurred while writing address 0x%x length 0x%0x" % (start, length))

def debug_write_supports_flash():
    return 1

def _get_pc():
    try:
        pc = dev.ReadReg64(15)
    except:
        log.error("get_pc returned error")
        return 0
    return pc
    
def _mem_read(start, length, data):
    dev.Read(start, data, 0, length)

def _mem_write(start, length, data):
    dev.Write(start, data, 0, length)

def _run_target():
    cache_onRun()
    wdt_onRun()
    dev.Write32(arm.DHCSR, 0xa05f0001)  # DBGKEY | C_DEBUGEN | C_HALT

def _halt_target():
    dev.Write32(arm.DHCSR, 0xa05f0003)  # DBGKEY | C_DEBUGEN | C_HALT

def _step_target():
    cache_onRun()
    wdt_onRun()
    dev.Write32(arm.DHCSR, 0xa05f000b)  # DBGKEY | C_DEBUGEN | C_HALT | C_MASKINTS
    dev.Write32(arm.DHCSR, 0xa05f000d)  # DBGKEY | C_DEBUGEN | C_STEP | C_MASKINTS
    dev.Write32(arm.DHCSR, 0xa05f0003)  # DBGKEY | C_DEBUGEN | C_HALT
    cache_onStop()
    wdt_onHalt()

def _set_pc(pc):
    dev.WriteReg64(15, pc)

def print_byte_array(text, array, index, size):
    string = text
    for i in range(size):
        string += " %x" % array[i+index]
    log.info(string)

g_is_running = True
def _is_target_running():
    global g_is_running
    dhcsr = dev.Read32(arm.DHCSR)
    state = 0 == (dhcsr & 0x20000)
    if state != g_is_running:
        log.info("Debug: target is now running" if state else "Debug: target has halted")
        g_is_running = state 
    if not g_is_running:
        cache_onStop()
        wdt_onHalt()
    return g_is_running

def _reset_target(): 
    reset_and_halt()

def ensure_connect():
    global has_connected
    if has_connected:
        return
    dev.Connect(comm_iface, comm_speed)
    has_connected = True

def _end_debug_session(): 
    #disable hw bp
    fpb = dev.Read32(0xe0002000)
    if 0 != (fpb & 1):
        dev.Write32(0xe0002000,2|(fpb&0xFFFFfffe))
    run_target()


def set_sw_bp_gen(address, erase_size, instruction, flags):  #mplab
    global erase_as_needed
    log.debug("Debug: set/reset bp at address 0x%0x, store instructions 0x%0x, flags = 0x%0x" % (address, instruction, flags))
    if address >= 0x20000000:
        erase_size = 4 
    else:
        clear_and_report_flash_error()


    erase_page_start = address & ~(erase_size-1)
    address_in_erase_page = address & (erase_size-1)

    data = bytearray(erase_size)
    cache_invalidateInstrCache()
    dev.Read(erase_page_start, data, 0, erase_size)
    return_value = data[address_in_erase_page] | (data[address_in_erase_page+1] << 8)

    # Insert software breakpoint instruction in the data
    data[address_in_erase_page] = instruction & 0xFF
    data[address_in_erase_page+1] = (instruction >> 8) & 0xFF

    if erase_size == 4:
        dev.Write(erase_page_start, data, 0, erase_size)
    else:
        erase_as_needed = True
        prog_write("Pgm", erase_page_start, erase_size, data)
    return return_value

# device specific functions


def dap_Read8(adr):
    return dev.Read8(adr)

def dap_Write8(adr,val):
    return dev.Write8(adr,val)

def dap_Read16(adr):
    return dev.Read16(adr)

def dap_Write16(adr,val):
    return dev.Write16(adr,val)

def dap_Read32(adr):
    return dev.Read32(adr)

def dap_Write32(adr,val):
    return dev.Write32(adr,val)

def dap_Read(adr,b,o,l):
    return dev.Read(adr,b,o,l)

no_device = False

class arm_const:
    DHCSR = 0xE000EDF0
    DEMCR = 0xE000EDFC
    AIRCR = 0xE000ED0C

    def getDHCSRString(self, num):
        return str(num)

def set_globals(dev_copy, utils_copy, settings_copy, device_copy, log_copy):
    global dev, utils, settings, device, log, arm, no_device
    arm = arm_const()
    dev = dev_copy
    utils = utils_copy
    settings = settings_copy
    device = device_copy
    log = log_copy
    no_device = True

def set_globals2(dev_copy, utils_copy, settings_copy, device_copy, log_copy, arch):
    global architecture
    architecture = arch
    set_globals(dev_copy, utils_copy, settings_copy, device_copy, log_copy)

def _hold_in_reset(): 
    global has_reset, has_connected

    if not has_reset:
        alt_hold_in_reset()
        return
    log.info("Prog: Hold in reset")
    dev.Pins(0, dev.RESET, 1000)
    #  The debugger needs to stay connected to actively keep the reset line low.
    has_connected = False # Pins ends debug session, so a reconnect will be neeeded


def alt_hold_in_reset(): 
    # Alternative if RESET pin is not connected to debugger
    log.info("Prog: Hold in reset , no reset line")
    reset_and_halt()

def _release_from_reset():
    global reset_delay
    global has_reset
    if not has_reset:
        log.info("Prog: Release from reset (soft reset)")
        reset_and_halt()
        run_target()
        return
    log.info("Prog: Release from reset (float reset line)")
    dev.Pins(0, dev.RESET, 1000)
    dev.Delay(reset_delay)
    dev.Pins(dev.RESET, dev.RESET, 1000)  # now float reset back
    dev.Delay(reset_delay)

def alt_release_from_reset():
    log.info("Prog: Release from reset, no reset line")
    dev.Write32(dev.AIRCR, 0x05fa0004)  # VECTKEY | SYSRESETREQ
def cache_invalidate():
    if "G55" in device:
        dev.Write32(0x4003C020,1)
    elif "SAM4" in device:
        dev.Write32(0x4007C020,1)
    if "PIC32CX" in device:
        dev.Write32(0x46008020,1) #CMCC0
        dev.Write32(0x4600C000,1) #CMCC1

def cache_onDebugStart():
    cache_invalidate()
def cache_onStop():
    cache_invalidate()
def cache_onRun():
    pass    
def cache_onDataRead(adr,size):
    pass #done in onStop
def cache_onDataWrite(adr,size):
    pass #done in onStop
def cache_invalidateInstrCache():
    pass #done in onStop

def wdt_onRun():
    pass
def wdt_onHalt():
    pass
efc_cmd_wp   = 0x5a000001
efc_cmd_ewp  = 0x5a000003
efc_cmd_ea   = 0x5a000005
efc_cmd_epa  = 0x5a000007
efc_cmd_slb  = 0x5a000008
efc_cmd_clb  = 0x5a000009
efc_cmd_glb  = 0x5a00000a
efc_cmd_sgpb = 0x5a00000B
efc_cmd_cgpb = 0x5a00000C
efc_cmd_ggpb = 0x5a00000D


if "RH7" in device:
    FLASH_START = 0x10000000
    PAGE_SIZE = 256
    PAGE_PER_LOCKBIT = 1 
    # Bit mask for user changeable GPNVM bits
    if "RH71" in device:
        GPNVM_BIT_MASK = bytearray(b'\x02\x07\0\0\xFF\xFF\xFF\x0F\xFF\xFF\xFF\x0F\xFF\xFF\xFF\x0F')   
    else:  # RH707
        GPNVM_BIT_MASK = bytearray(b'\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF')   
    #GPNVM_BIT_MASK = 0x0FFFFFFF0FFFFFFF0FFFFFFF00000702L   # Bit mask for user changeable GPNVM bits
    chipid = 0x40100000  # HEFC CHIPID register
    efc_fmr  = 0x40004000  # HEFC Flash Mode Register
    efc_fcr  = 0x40004004  # HEFC Flash Command Register
    efc_fsr  = 0x40004008  # HEFC Flash Status Register
    efc_frr  = 0x4000400c  # HEFC Flash Result Register
    efc_fpmr = 0x40004040  # HEFC Flash Power Management Register
    efc_wpmr = 0x400040e4  # HEFC Write Protection Mode Register
    efc_cmd_ep = 0x5a000006  # available on SAMRH7, but not available on Canopus (SAME70, S70, V70/71)
    rstc_cr = 0x40100200
    rstc_sr = 0x40100204
    rstc_mr = 0x40100208
elif "M7" in architecture:
    FLASH_START = 0x0400000
    PAGE_SIZE = 512
    PAGE_PER_LOCKBIT = 32
    GPNVM_BIT_MASK = bytearray(b'\x83\x01\0\0')  #    GPNVM_BIT_MASK = 0x183 # Bit mask for user changeable GPNVM bits
    chipid = 0x400e0940  # EEFC CHIPID register
    efc_fmr  = 0x400e0c00  # EEFC Flash Mode Register
    efc_fcr  = 0x400e0c04  # EEFC Flash Command Register
    efc_fsr  = 0x400e0c08  # EEFC Flash Status Register
    efc_frr  = 0x400e0c0c  # EEFC Flash Result Register
    efc_wpmr = 0x400e0ce4  # EEFC Write Protection Mode Register
    efc_cmd_ewp = 0x5a000003  # available on Canopus (SAME70, S70, V70/71), but not available on SAMRH7
    efc_cmd_ewpl = 0x5a000004  # available on Canopus (SAME70, S70, V70/71), but not available on SAMRH7
    rstc_cr = 0x400e1800
    rstc_sr = 0x400e1804
    rstc_mr = 0x400e1808
elif "PIC32CX" in device:
    FLASH_START = 0x01000000
    PAGE_SIZE = 512
    PAGE_PER_LOCKBIT = 16
    GPNVM_BIT_MASK = bytearray(b'\xFF\x01\0\0')  #    GPNVM_BIT_MASK = 0x183 # Bit mask for user changeable GPNVM bits
    chipid = 0x40050200

    rstc_mr = 0x40053008
    rstc_cr = 0x40053000
    rstc_sr = 0x40053004
    WRITE_CHUNK_SIZE = 512
    ERASE_SECTOR_SIZE = 4096

else: #sam3 and sam4 devices 
    FLASH_START = 0x0400000
    PAGE_SIZE = 512
    PAGE_PER_LOCKBIT = 16
    GPNVM_BIT_MASK = bytearray(b'\x83\x01\0\0')  #    GPNVM_BIT_MASK = 0x183 # Bit mask for user changeable GPNVM bits
    chipid = 0x400e0740  # EEFC CHIPID register
    efc_fmr  = 0x400e0a00  # EEFC Flash Mode Register
    efc_fcr  = 0x400e0a04  # EEFC Flash Command Register
    efc_fsr  = 0x400e0a08  # EEFC Flash Status Register
    efc_frr  = 0x400e0a0c  # EEFC Flash Result Register
    rstc_cr = 0x400e1400
    rstc_sr = 0x400e1404
    rstc_mr = 0x400e1408

def log_efc_fsr_error(fsr):
    err_string = ""
    if "M7" in architecture:
        if fsr & 0x00080000: # FSR_MECCEMSB
            err_string = "MECCEMSB"
        if fsr & 0x00040000: # FSR_UECCEMSB
            err_string += " UECCEMSB"
        if fsr & 0x00020000: # FSR_MECCELSB
            err_string += " MECCELSB"
        if fsr & 0x00010000: # FSR_UECCELSB
            err_string += " UECCELSB"
        if fsr & 0x10: # FSR_WREER
            err_string += " WREER"
    if fsr & 8: # FSR_FLERR
        err_string += " FLERR"
    if fsr & 4: # FSR_FLOCKE
        err_string += " FLOCKE"
    if fsr & 2: # FSR_FCMDE
        err_string += " FCMDE"
    if err_string == "":
        return
    err_string = "Flash controller error " + err_string 
    raise Exception(err_string)

def waitForFlashReady():
    n = 0
    max_retries = 115
    delay = 1000
    while n < max_retries:
        r = dev.Read32(efc_fsr)
        log_efc_fsr_error(r)
        if r & 1: # FSR_FRDY:
            break
        if n > 10:
            delay = 10000
        if n > 15:
            delay = 100000
        dev.Delay(delay) 
        n = n+1
    if n == max_retries:
        raise Exception("Timeout waiting for flash ready")

def eefc_cmd(cmd):
    dev.Write32(efc_fcr, cmd)
    waitForFlashReady()


mem_plane_size = 0
bank_flip = False

def select_efc0():
    if not "PIC32CX" in device:
        return
    global efc_fmr,efc_fcr,efc_fsr,efc_frr
    efc_fmr  = 0x460E0000  # SEFC0  Flash Mode Register
    efc_fcr  = 0x460E0004  # SEFC0 Flash Command Register
    efc_fsr  = 0x460E0008  # SEFC0 Flash Status Register
    efc_frr  = 0x460E000c  # SEFC0 Flash Result Register

def select_efc1():
    global efc_fmr,efc_fcr,efc_fsr,efc_frr
    efc_fmr  = 0x460E2000  # SEFC1  Flash Mode Register
    efc_fcr  = 0x460E2004  # SEFC1 Flash Command Register
    efc_fsr  = 0x460E2008  # SEFC1 Flash Status Register
    efc_frr  = 0x460E200c  # SEFC1 Flash Result Register

def select_efc(adr):
    global mem_plane_size, bank_flip
    if not "PIC32CX" in device:
        return
    if "5112" in device:
        mem_plane_size =  0x40000
    elif "2051" in device:
        mem_plane_size =  0x100000
    else:
        mem_plane_size = 0x00080000
    adr = adr & 0x00FFffff
    first_plane = (adr  < mem_plane_size) ^ bank_flip
    
    if first_plane:
        select_efc0()
    else:
        select_efc1()

def write_config(address, length, data):
    log.info("Prog: write_config at address 0x%0X, length 0x%0X" % (address, length))
    select_efc0()    
    # Converting value to indexing access, and writing one GPNVM bit at the time
    if address == 0xD0000000:
        bit_index = 0
        for i in range(len(GPNVM_BIT_MASK)):
            val = data[i]
            for bit in range(8):
                if((GPNVM_BIT_MASK[i] >> (bit_index&7)) & 1):
                    if val  & (1 << bit):
                        log.info("Debug: Setting GPNVM bit %d" % bit_index)
                        eefc_cmd( efc_cmd_sgpb | (bit_index << 8))
                    else:
                        log.info("Debug: Clearing GPNVM bit %d" % bit_index)
                        eefc_cmd( efc_cmd_cgpb | (bit_index << 8))
                bit_index += 1
    elif address == 0xD0000004 or "RH7" in device and address == 0xD0000010:
        bit_index = 0
        if "RH7" in device:
            NUM_LOCK_BYTES = 4
        else:
            NUM_LOCK_BYTES = len(data)
        for i in range(NUM_LOCK_BYTES):
            val = data[i]
            for bit in range(8):
                if val  & (1 << bit):
                    log.info("Debug: Setting Lock bit %d" % bit_index)
                    eefc_cmd( efc_cmd_slb | (bit_index * PAGE_PER_LOCKBIT << 8))
                else:
                    log.info("Debug: Clearing Lock bit %d" % bit_index)
                    eefc_cmd( efc_cmd_clb | (bit_index * PAGE_PER_LOCKBIT << 8))
                bit_index += 1

def read_config(address, length, data):
    log.info("Prog: read_config at address 0x%0X, length 0x%0X" % (address, length))
    select_efc0()
    if address == 0xD0000000:
        eefc_cmd(efc_cmd_ggpb)
    elif address == 0xD0000004 or "RH7" in device and address == 0xD0000010:
        eefc_cmd(efc_cmd_glb)

    for read_index in range(data.__len__()):
        if read_index % 4 == 0:
            read_data = dev.Read32(efc_frr)
            log.info("Prog: Config bits at address 0x%0X, value: 0x%0X" % (address, read_data))
        data[read_index] = 0xFF & read_data
        read_data = read_data >> 8

def _handle_security_flags(address, length, data): 
    return False

HLTDBG = 1<<29
def halt_wdt_mistral():
    global old_dwdt0,old_dwdt1,sysc_wpmr
    sysc_wpmr = dev.Read32(0x400531A0)
    old_dwdt0 = dev.Read32(0x40053214)
    old_dwdt1 = dev.Read32(0x40052004)
    if 1 == (sysc_wpmr & 0x1):
        dev.Write32(0x400531A0, 0x53594300 | (sysc_wpmr & ~0x1))
 
    if 0 == (old_dwdt0 & HLTDBG):
        dev.Write32(0x40053214, old_dwdt0 | HLTDBG)

    if 0 == (old_dwdt1 & HLTDBG):
        dev.Write32(0x40052004, old_dwdt1 | HLTDBG)


def restore_wdt_mistral():
    if 0 == (old_dwdt0 & HLTDBG):
        dev.Write32(0x40053214, old_dwdt0 )

    if 0 == (old_dwdt1 & HLTDBG):
        dev.Write32(0x40052004, old_dwdt1 )

    if 1 == (sysc_wpmr & 0x1):
        dev.Write32(0x400531A0, 0x53594300 | sysc_wpmr) # Restore SYSC write-protection
def _begin_programming_operation():
    old_fmr = -1  #sentinel value to trigger reread of config
    ensure_connect()
    reset_and_halt() 

def _read_device_id():
    return dev.Read32(chipid)

def halt_or_raise():
    halt_target()
    n = 0
    while n < 5:
        if not is_target_running():
            return
        dev.Delay(100000) # 100ms
        n = n+1
    raise Exception("Failed to halt target!")

def halt_wdt_e70():
    #todo
    pass

def resetPeripheralsWithRstc():
    dev.Write32(rstc_mr, 0xa5000b00) # long(RSTC_KEY) | rstc_erstl)
    if "SAMG5" in device:
        dev.Write32(rstc_cr, 0xa5000004)  # long(RSTC_KEY) | PERRST)
    else:
        dev.Write32(rstc_cr, 0xa5000001)  # long(RSTC_KEY) | PROCRST)

    n = 0
    max_retries = 100
    while n < max_retries:
        dev.Delay(10000)  # 10ms
        r = dev.Read32(rstc_sr)
        if r & 0x00020000: # SRCMP
            continue  # Software reset in progress
        if r & 0x00010000: # NRSTL
            break
        n = n+1
    if n == max_retries:
        raise Exception("timeout in reset")
    dev.Write32(rstc_mr, 0xa5000001) # long(RSTC_KEY) | URSTEN) # Enable user reset again (URSTEN == 1)

def _erase_internal():
    if "PIC32CX" in device:
        #todo
        select_efc(0)
        for i in range(mem_plane_size/4096):
            _erase_flash_sector(0x01000000 + i*4096)
        select_efc(mem_plane_size)
        for i in range(mem_plane_size/4096):
            _erase_flash_sector(0x01000000 + i*4096)
        return

    try:
        eefc_cmd(efc_cmd_ea)
    except:
        r = dev.Read32(efc_fsr)
        if r & 4 :  # lock error
            if "RH7" in device:
                for i in range(32):
                    eefc_cmd(0x5a000009 | (i*256))
                eefc_cmd(efc_cmd_ea)
            else:
                raise


def reconnectAfterReset():
    dev.Disconnect()
    dev.Connect(comm_iface, comm_speed)

def reset_vectorcatch():
    dev.Pins(0, dev.RESET, 1000)
    dev.Delay(10)
    dev.Pins(dev.RESET, dev.RESET, 1000)  # now float reset back
    dev.Disconnect()
    dev.Connect(comm_iface, comm_speed)
    dev.Write32(arm.DEMCR, 0x01000000)

def reset_aircr():
    if "RH7" in device:
        # SAMRH7 use SYSRESETREQ to reset core + peripherals, will loose connection so need to reconnect.
        try:
            dev.Write32(arm.AIRCR, 0x05fa0004) # VECTKEY | SYSRESETREQ)  # 1=VECTRESET 4=SYSRESETREQ
        except:
            log.info("Reset with SYSRESETREQ, lost connection, try to reconnect to the device")
        dev.Disconnect()
        dev.Connect(comm_iface, comm_speed)
    else:
        # Canopus use RSTC (PROCRST) to reset peripherals and VECTRESET to reset core.
        resetPeripheralsWithRstc()
        dev.Write32(arm.AIRCR, 0x05fa0001) # VECTKEY | VECTRESET)  # 1=VECTRESET 4=SYSRESETREQ


def reset_and_halt():
    log.info("Prog: Reset and halt")
    if "PIC32CX" in device:    
        fp0 = dev.Read32(0xE0002008)
        rstaddr = dev.Read32(0x01000004)
        e2008 = dev.Read32(0xE0002008)
        e2000 = dev.Read32(0xE0002000)
        dev.Write32(0xE0002008,(rstaddr | (0x3 << 30)))
        dev.Write32(0xE0002000,3)
        dev.Write32(rstc_cr, 0xa5000005)  # long(RSTC_KEY) | PROCRST)
        dev.Delay(500000)
        reconnectAfterReset()
        dev.Write32(0xE0002008,e2008)
        dev.Write32(0xE0002000,e2000)
        dhcsr = dev.Read32(arm.DHCSR)
        hasHalted = 0 != (dhcsr & 0x20000) # S_HALT
        if not hasHalted:
            halt_target()
        return


    halt_or_raise()

    dev.Write32(arm.DEMCR, 0x01000001) # TRCENA | VC_CORERESET) 

    if settings.getBool("script.reset_by_pin", False):
        reset_vectorcatch()
        dhcsr = dev.Read32(arm.DHCSR)
        print_dhcsr_v("State after pin reset ", dhcsr)
        return
    else:
        reset_aircr()

    n = 0
    max_retries = 100
    seenReset = False
    while n < max_retries:
        dhcsr = dev.Read32(arm.DHCSR)
        #log.info("S_RESET_ST = %s / %s at PC = %X" % ("1" if dhcsr & 0x02000000 else "0", "Halted" if dhcsr & 0x20000 else "RUNNING", get_pc()))
        if (dhcsr & 0x02000000): # wait for S_RESET_ST
            seenReset = True
        hasHalted = 0 != (dhcsr & 0x20000) # S_HALT
        if seenReset:
            if hasHalted:  # wait for S_HALT
                break
        dev.Delay(100000) # 100ms
        n = n+1
    dev.Write32(arm.DEMCR, 0x01000000) # TRCENA reset VC_CORERESET bit
    
    if n == max_retries:
        raise Exception("Timeout in reset")
    if "RH7" in device:
        initialize_HEFC()
    wdt_onHalt()

    
def write_flash_page(adr, ofs, data, cmd):
    log.debug("Write flash page adr=0x%0x, ofs=0x%0x" % (adr, ofs))
    dev.Write(adr, data, ofs, PAGE_SIZE)
    if "RH7" in device:
        page_number = adr & 0x3fff00 # SAMRH7 has page_size 256
    else:
        page_number = (adr & 0x3ffe00) >> 1 # Canopus has page_size 512
    eefc_cmd(cmd | page_number)
    log.debug("Written page %d (0x%0x) at 0x%0x" % (page_number >> 8, page_number*2, adr))

def _prog_write_internal(type_of_mem, address, length, data): 
    global erase_as_needed
    if address >= 0xd0000000 and address < 0xd0000100:
        type_of_mem = "Cfg" # force cfg mem type to work around rh71.EBI_CSHEMC overlapping the range that was virtually reserved for cfgbits
    if str(type_of_mem) == "Cfg":
        write_config(address, length, data)
        return  
    elif str(type_of_mem) != "Pgm":
        dev.Write(address, data, 0, length)
        return
    if "RH7" not in device: # SAMRH7 don't support wait states (ref prelim data sheet)
        # Set Flash Wait States to 7 cycles (6+1)
        if "PIC32CX" not in device:
            dev.Write32(efc_fmr, 0x00000600)
    _flash_write( address, length, data, erase_as_needed)

old_fmr = -1

def _pre_flash_write(address):
    global old_fmr,bank_flip
    
    if "PIC32CX" in device:
        if old_fmr == -1:
            gpnvm = bytearray(4)
            read_config(0xD0000000, 4, gpnvm)
            bank_flip = gpnvm[0] & 2
            old_fmr = dev.Read32(efc_fmr)
        select_efc(address)
        dev.Write32(efc_fmr,old_fmr|0x60)
    
def _post_flash_write():
    dev.Write32(efc_fmr,old_fmr)
    
def _erase_flash_sector(addr):
    log.info("Erasing at addr " + hex(addr))
    select_efc(addr)
    eefc_cmd(efc_cmd_epa | (addr >> 1) | 0x100)  #erase 8 pages

def _write_small_chunk(address, data_offset, data,length):
    write_flash_page(address, data_offset, data, efc_cmd_wp)


def _write_flash_sector(address, data_offset, data,length):
    current_ofs = 0
    while current_ofs < length:
        _write_small_chunk(address,current_ofs + data_offset,data, min(length-current_ofs,WRITE_CHUNK_SIZE))
        current_ofs += WRITE_CHUNK_SIZE
        address += WRITE_CHUNK_SIZE

def _flash_write_rng(address, length, data, do_erase):
    written = 0
    _pre_flash_write(address)
    while written < length:
        if do_erase != 0:
            _erase_flash_sector(address)
        _write_flash_sector(address, written, data, min(length-written,ERASE_SECTOR_SIZE))
        written += ERASE_SECTOR_SIZE
        address += ERASE_SECTOR_SIZE
    _post_flash_write()


def _flash_write(address, length, data, doerase):
    written = 0
    if "PIC32CX" in device:
        _flash_write_rng(address,length,data,doerase)
        return
    if "RH7" in device:
        # note that this code expects length to be a multiple of PAGE_SIZE
        while written < length:
            page_number = address & 0x3fff00 # SAMRH7 has page_size 256
            # Erase and write page (two separate commands on SAMRH7)
            if doerase:  
                eefc_cmd(efc_cmd_ep | page_number)
            write_flash_page(address,written,data,efc_cmd_wp)
            written += PAGE_SIZE
            address += PAGE_SIZE
        return
    while written < length:
        if (address & (FLASH_START-1)) < (2 * 8 * 1024):
            buffer_size = PAGE_SIZE
            cmd = efc_cmd_ewp if doerase else efc_cmd_wp
        else:
            if doerase:
                #erase 16 pages
                addr = address & 0x003FF000 #isolate page number
                eefc_cmd(efc_cmd_epa | (addr >> 1) | 0x200)
            cmd = efc_cmd_wp
            buffer_size = PAGE_SIZE * 16
        write_len = min(length - written, buffer_size)
        while write_len > 0:
            write_flash_page(address, written, data, cmd)
            written += PAGE_SIZE
            address += PAGE_SIZE
            write_len -= PAGE_SIZE

def _prog_read_internal(type_of_mem, address, length, data):    
    if str(type_of_mem) == "Cfg":
        read_config(address, length, data)
        return
    dev.Read(address, data, 0, length)

def _end_of_operations():
    log.info("Prog: End of operations")
    pass

def clear_and_report_flash_error():
    try:
        waitForFlashReady()
    except:
        log.error("NVM controller is in an error state while setting a swbp. Clearing the error")

def set_sw_bp(address, instruction, flags):
    if (address & (FLASH_START-1)) < 16384 or "RH7" in device:
        return set_sw_bp_gen(address, PAGE_SIZE,instruction,flags)
    return set_sw_bp_gen(address, 16*PAGE_SIZE, instruction, flags)

target_was_reset = False
debug_session  = True

def begin_communication_session(): #mplab
    log.info("Begin comm session")
    _begin_communication_session()

def end_communication_session(): #mplab
    log.info("End comm session")
    _end_communication_session()

def begin_programming_operation(): #mplab
    global debug_session
    log.info("Begin operations")
    debug_session = False
    _begin_programming_operation()

def erase(): #mplab
    log.info("Erase")
    _erase()

def prog_write(type_of_mem, address, length, data): #mplab
    log.info("Writing %08x bytes to address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_write(type_of_mem, address, length, data)

def prog_read(type_of_mem, address, length, data): #mplab
    log.info("Reading %08x bytes from address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_read(type_of_mem, address, length, data)

def end_of_operations():#mplab
    log.info("End of operations")
    _end_of_operations()

def begin_debug_session():  #mplab
    log.info("Debug: Init debug session")
    global debug_session
    debug_session = True
    _begin_debug_session()

def debug_read(mt, start, length, data):  #mplab
    log.info("Debug: Reading %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_read(mt, start, length, data)

def debug_write(mt, start, length, data):  #mplab
    log.info("Debug: Writing %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_write(mt, start, length, data)

def set_pc(pc):  #mplab
    log.info("Debug: set pc to 0x%08x" % pc)
    _set_pc(pc)

def get_pc():  #mplab
    pc = _get_pc()
    log.info("Debug: get_pc PC=0x%08x" % pc)
    return pc

def run_target():#mplab
    log.info("Debug: run target")
    _run_target()

_stealth_runstate = 2
def halt_target():  #mplab
    global _stealth_runstate    
    log.info("Debug: halt target")
    _stealth_runstate = 2  # cancels stealth mode
    _halt_target()

def step_target():  #mplab
    log.info("Debug: stepping at pc 0x%08x" % get_pc())
    _step_target()

def reset_target(): #mplab
    log.info("Debug: reset")
    _reset_target()
    on_after_reset() # call autoload hook

def is_target_running():#mplab
    global _stealth_runstate
    if _stealth_runstate == 2:
        return _is_target_running()
    return _stealth_runstate != 0

def on_after_reset(): 
    if not debug_session:
        return
    if not settings.getBool("arm.use_vtor", False):
        return
    vtor_name  = settings.getString("arm.vtor_adr", "0")

    vtor = -1
    try:
        vtor = int(vtor_name,0)
    except:
        try:
            vtor=deb.GetSymbolAddress(vtor_name)
        except:
            log.error("Debug: failed to compute location of VTOR")
            return
    load_vtor(vtor) 
    pass

def load_vtor(adr):
    try:
        pc = dev.Read32(adr + 4)
        sp = dev.Read32(adr)
        set_pc(pc)
        dev.WriteReg64(arm.SP,sp)
        log.info("Setting pc=%08x and sp=%08x" % (pc, sp))
    except:
        log.error("Debug: failed to set PC and SP to contents of exception_table")

def on_program_done():
    on_after_reset()

def end_debug_session():  #mplab
    log.info("Debug: End debug session")
    _end_debug_session()

def verify_transfer(type_of_mem, address, data, length):  #mplab
    log.info("Verifying %08x bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
    _verify_transfer(type_of_mem, address, data, length)

    

def _verify_transfer(type_of_mem, address, data, length):
    if len(data) != length:
        raise Exception("The given data and length mismatch")
    d = bytearray(length)
    prog_read(type_of_mem, address, length, d)
    if str(type_of_mem) == "Cfg":
        verify_config(address, data, d, "verify")
    else:
        for i in range(length):
            if data[i] != d[i]:
                raise Exception("Verify failed for mem type {}, at address 0x{:X}".format(str(type_of_mem), address + i))

global dev_cfg_masks_bytearray
dev_cfg_masks_bytearray = None

def init_masks_as_bytearray():
    global dev_cfg_masks_bytearray
    if dev_cfg_masks_bytearray:
        return
    dev_cfg_masks_bytearray = {}
    for address, val in dev_cfg_masks.items():
        dev_cfg_masks_bytearray[address    ] = int(val      ) & 0xFF
        dev_cfg_masks_bytearray[address + 1] = int(val >> 8 ) & 0xFF
        dev_cfg_masks_bytearray[address + 2] = int(val >> 16) & 0xFF
        dev_cfg_masks_bytearray[address + 3] = int(val >> 24) & 0xFF

def verify_config(address, expected, actual, error_string_prefix):
    try:
        # older versions of MPLAB X (<=v5.45) did not pass dev_cfg_masks
        # so very_config cannot be executed
        dev_cfg_masks 
    except:
        raise Exception("{} config is not implemented".format(error_string_prefix))
    init_masks_as_bytearray()

    for index, actual_val in enumerate(actual):
        current_address = address + index
        if current_address in dev_cfg_masks_bytearray:
            mask = dev_cfg_masks_bytearray[current_address]
            expected_val = expected[index] & mask
            actual_val &= mask
            if actual_val != expected_val:
                error_string = "{} failed at address 0x{:0X}, expected 0x{:0X}, got 0x{:0X}".format(error_string_prefix, current_address, expected_val, actual_val)
                raise Exception(error_string)

def is_memory_blank_all_ffs(type_of_mem):
    return str(type_of_mem) == "Pgm" or str(type_of_mem) == "UserID"
        
def blank_check():  #mplab
    log.info("Blank check")

def blank_check_mem(type_of_mem, address, length):  #mplab
    msg.print("Blank checking %08x bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
    _blank_check_mem(type_of_mem, address, length)

def _blank_check_mem(type_of_mem, address, length):
    data = bytearray(length)
    prog_read(type_of_mem, address, length, data)
    if str(type_of_mem) == "Cfg":
        prog_read(type_of_mem, address, length, data)
        verify_config(address, data, data, "blank check")
    elif is_memory_blank_all_ffs(type_of_mem):
        for index, x in enumerate(data):
            if x != 255:
                raise Exception("Blank failed for mem type {}, at address 0x{:X}".format(str(type_of_mem), address + index))
    else:
        log.error("Blank check, ignoring {}".format(str(type_of_mem)))

def hold_in_reset():  #mplab
    log.info("Hold in reset")
    _hold_in_reset()

def release_from_reset():  #mplab
    log.info("Release from reset")
    _release_from_reset()
    
def read_device_id():#mplab
    log.info("Read device ID")
    return _read_device_id()

import os
has_samba = os.path.isfile(os.path.join("samba.py"))
if has_samba:
    import samba
from xml.dom import minidom


class MemHandlers():
    def __init__(self, board_file):
        if has_samba:
            samba.log = log
            samba.msg = msg
            samba.dev = dev
            samba.is_target_running = is_target_running
            samba.run_target = run_target
            samba.architecture = architecture
            samba.arm = arm
        self.parse_board_file(board_file)

    def parse_board_file(self, board_file):
        self.handlers = []
        xmldoc = minidom.parse(board_file)
        rangeNodes = xmldoc.getElementsByTagName("range")
        for rangeNode in rangeNodes:
            start = int(rangeNode.getAttribute("start"), 0)
            end = int(rangeNode.getAttribute("end"), 0)
            type = rangeNode.getAttribute("type")
            config = {}
            for configNode in rangeNode.childNodes:
                if configNode.nodeType == configNode.ELEMENT_NODE:
                    try:
                        config[configNode.tagName] = int(configNode.firstChild.nodeValue, 0)
                    except:
                        config[configNode.tagName] = ide.expandProjectMacros("${ProjectName}", configNode.firstChild.nodeValue).replace("\\", os.path.sep)
            if type == "samba" and has_samba:
                self.handlers.append(samba.Samba(start, end, config))
            elif type == "user":
                self.handlers.append(UserHandler(start, end, config))

    def prog_write(self, type_of_mem, address, length, data):
        log.info("Prog: Writing %d bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
        global erase_as_needed
        remainings = [[address, address + length]]
        for handler in self.handlers:
            write_start = max(address, handler.range_start)
            write_end = min(address + length, handler.range_end)
            if write_start < write_end:
                # chop the data buffer and pass it to handler and run
                if erase_as_needed:
                    handler.erase(write_start - handler.range_start, write_end - write_start)
                handler.write(write_start - handler.range_start, data[write_start - address: write_end - address])
            new_remainings = []
            for remaining in remainings:
                write_start = max(remaining[0], handler.range_start)
                write_end = min(remaining[1], handler.range_end)
                if remaining[0] < write_start < remaining[1]:
                    new_remainings.append([remaining[0], write_start])
                if remaining[0] < write_end < remaining[1]:
                    new_remainings.append([write_end, remaining[1]])
                elif write_start < write_end < remaining[0] or remaining[1] < write_start < write_end or write_start > write_end:
                    new_remainings.append(remaining)
            remainings = new_remainings
        # now write to memory ranges that are not covered by handlers
        for remaining in remainings:
            _prog_write_internal(type_of_mem, remaining[0], remaining[1] - remaining[0], data[remaining[0] - address: remaining[1] - address])

    def prog_read(self, type_of_mem, address, length, data):
        log.info("Prog: Reading %d bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
        remainings = [[address, address + length]]
        for handler in self.handlers:
            read_start = max(address, handler.range_start)
            read_end = min(address + length, handler.range_end)
            if read_start < read_end:
                # chop the data buffer and pass it to handler and run
                buffer = bytearray(read_end - read_start)
                handler.read(read_start - handler.range_start, buffer)
                data[read_start - address: read_end - address] = buffer
            new_remainings = []
            for remaining in remainings:
                read_start = max(remaining[0], handler.range_start)
                read_end = min(remaining[1], handler.range_end)
                if remaining[0] < read_start < remaining[1]:
                    new_remainings.append([remaining[0], read_start])
                if remaining[0] < read_end < remaining[1]:
                    new_remainings.append([read_end, remaining[1]])
                elif read_start < read_end < remaining[0] or remaining[1] < read_start < read_end or read_start > read_end:
                    new_remainings.append(remaining)
            remainings = new_remainings
        # now write to memory ranges that are not covered by handlers
        for remaining in remainings:
            _prog_read_internal(type_of_mem, remaining[0], remaining[1] - remaining[0], data[remaining[0] - address: remaining[1] - address])

    def erase(self):
        log.info("Prog: Erasing memory")
        for handler in self.handlers:
            if handler.range_start < handler.range_end:
                handler.erase(0, handler.range_end - handler.range_start)


class UserHandler():
    def __init__(self, range_start, range_end, config):
        self.range_start = range_start
        self.range_end = range_end
        self.config = config

    def call(self, address=0, data=None):
        if "handler_name" in self.config.keys():
            eval(self.config["handler_name"])()
        else:
            log.info("The name of handler function is missing")


def _prog_write(type_of_mem, address, length, data):
    global mem_handlers
    if mem_handlers is None:
        _prog_write_internal(type_of_mem, address, length, data)
    else:
        mem_handlers.prog_write(type_of_mem, address, length, data)


def _prog_read(type_of_mem, address, length, data):
    global mem_handlers
    if mem_handlers is None:
        _prog_read_internal(type_of_mem, address, length, data)
    else:
        mem_handlers.prog_read(type_of_mem, address, length, data)


def _erase():
    global mem_handlers, erase_as_needed
    if mem_handlers is not None:
        mem_handlers.erase()
    _erase_internal()
    erase_as_needed = False  # tell prog_write not to erase rows prior to write


def init_mem_handlers():
    global mem_handlers
    mem_handlers = None
    try:
        board_file = ide.expandProjectMacros("${ProjectName}", settings.getString("loader.board_file", "${ProjectDir}/board.xboard"))
    except:
        board_file = "./board.xboard"
    if os.path.isfile(board_file):
        mem_handlers = MemHandlers(board_file)
